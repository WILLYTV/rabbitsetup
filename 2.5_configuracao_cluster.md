# 2.5 – Configuração de Cluster

## Visão Geral

O cluster RabbitMQ será composto por **5 nós** (node00 a node04), conforme descrito em `infra.md`. Todos os nós já devem ter executado os passos de instalação e configuração inicial (2.1, 2.2, 2.3, 2.4).

- **Alta disponibilidade:** Todos os nós participam do cluster, suportando mirrored queues e quorum queues para ambientes críticos.
- **Disc nodes:** Em versões recentes, todos os nós podem ser disc nodes (recomendado para resiliência).

## Configuração de nomes e resolução de hosts

### 1. Resolução de nomes dos nós

**Recomendado para ambientes corporativos:**
- Utilize DNS interno para garantir que todos os nós consigam resolver os nomes uns dos outros (ex: node00, node01, node02, node03, node04).
- O uso de DNS permite mudanças de IP sem impacto para o cluster.

Todos os nós devem conseguir resolver os nomes dos demais para garantir comunicação correta.

## Passos para formar o cluster

### 2. Parar o aplicativo RabbitMQ nos nós secundários
Execute nos nós que vão se juntar ao cluster (node01, node02, node03, node04):
```bash
sudo rabbitmqctl stop_app
```

### 3. Juntar os nós ao cluster


Execute nos nós secundários, sempre apontando para o nó inicial do cluster (**node00**).

**Checklist prático antes do join_cluster:**

1. **Conferir hostname e resolução:**
   - No node01, rode:
     ```bash
     hostname
     ping NOME_DO_NODE00
     ```
   - O ping deve responder e o nome do node00 deve ser o mesmo que aparece em `rabbitmqctl status` no node00.

2. **Conferir nome do nó RabbitMQ:**
   - No node00, rode:
     ```bash
     sudo rabbitmqctl status | grep 'Node'
     ```
   - Use exatamente esse nome (ex: `rabbit@nodeName00c` ou `rabbit@nodeName00c.internalenv.corp`, conforme aparece no status). **Na prática, normalmente é apenas o hostname curto, como `rabbit@nodeName00c`.**

3. **Padronizar o arquivo .erlang.cookie:**
   - O conteúdo do arquivo `/var/lib/rabbitmq/.erlang.cookie` deve ser idêntico em todos os nós.
   - No node00:
     ```bash
     sudo cat /var/lib/rabbitmq/.erlang.cookie
     ```
   - Copie esse conteúdo para os demais nós (node01 a node04):
     ```bash
     sudo nano /var/lib/rabbitmq/.erlang.cookie
     sudo chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie
     sudo chmod 400 /var/lib/rabbitmq/.erlang.cookie
     ```
   - Reinicie o serviço rabbitmq-server nos nós onde o cookie foi alterado:
     ```bash
     sudo systemctl restart rabbitmq-server
     ```

4. **Firewall/Portas:**
   - Confirme que a porta 25672/TCP está liberada entre os nós:
     ```bash
     nc -zv NOME_DO_NODE00 25672
     ```

5. **Serviço RabbitMQ:**
   - O serviço rabbitmq-server deve estar rodando no node00 (nó principal) e parado nos nós que vão se juntar.

**Exemplo de comando join_cluster:**
```bash
# No node01
sudo rabbitmqctl stop_app
sudo rabbitmqctl join_cluster rabbit@nodeName00c
sudo rabbitmqctl start_app
```
> Todos os nós secundários devem se juntar ao cluster iniciado pelo node00, usando o nome exato do nó principal. Não utilize rabbit@node01, rabbit@node02, etc. como destino.
> Dica: O nome do nó principal geralmente é apenas o hostname curto (ex: `rabbit@nodeName00c`). Use exatamente o que aparece em `rabbitmqctl status` no node00.
#### Checklist de troubleshooting para erro de conexão (ex: `{erpc,noconnection}`)

Se aparecer erro de conexão ao rodar o join_cluster, revise todos os itens do checklist acima. Os problemas mais comuns são:
- Nome do nó incorreto (use sempre o nome exato do node00)
- .erlang.cookie diferente entre os nós
- Falha de resolução de nomes ou firewall bloqueando porta 25672

Corrija qualquer inconsistência e tente novamente o comando join_cluster.

### 4. Iniciar o aplicativo RabbitMQ nos nós secundários
```bash
sudo rabbitmqctl start_app
```

### 5. Verificar status do cluster
Em qualquer nó:
```bash
sudo rabbitmqctl cluster_status
```

---

## Melhores práticas para alta disponibilidade


- **Mirrored Queues:**
  - Use políticas para replicar filas críticas entre os nós.
  - Exemplo de política para todas as filas (pode ser executado em qualquer nó do cluster):
    ```bash
    sudo rabbitmqctl set_policy ha-all ".*" '{"ha-mode":"all"}' --priority 1 --apply-to queues
    ```
  - Para verificar se a política foi aplicada:
    ```bash
    sudo rabbitmqctl list_policies
    ```
    O resultado deve mostrar a política `ha-all` aplicada.
  - Mirrored queues são recomendadas para compatibilidade, mas para novos projetos prefira quorum queues.

- **Quorum Queues:**
  - São nativamente distribuídas e tolerantes a falhas, recomendadas para novos projetos.
  - Não dependem de política global: cada fila deve ser criada explicitamente como tipo quorum.
  - Exemplo de criação via CLI (rabbitmqadmin):
    ```bash
    sudo rabbitmqadmin declare queue name=nome_da_fila type=quorum durable=true
    ```
  - Exemplo via Management UI:
    - Ao criar uma fila, selecione o tipo "quorum" no campo "Type".
  - Para listar filas quorum já criadas:
    ```bash
    sudo rabbitmqctl list_queues name type
    ```
    O tipo da fila deve aparecer como `quorum`.

- **Sincronização de horário:**
  - Todos os nós devem estar com NTP ativo para evitar problemas de cluster.

---

> **Notas:**
> - O comando `join_cluster` só é executado nos nós que vão se juntar ao cluster (node01 a node04). O node00 é o nó inicial.
> - Todos os nós devem ter as mesmas configurações de usuário, vhost e permissões para garantir consistência.
> - Para ambientes críticos, monitore o cluster e configure alertas para falhas de nó ou de sincronização de filas.
> - A ativação dos plugins de gerenciamento e monitoramento está detalhada nos passos 2.6 e 2.7 deste guia.
> - **Importante:** O suporte a alta disponibilidade (mirrored queues e quorum queues) depende de políticas e configurações aplicadas após o cluster estar formado. A etapa de cluster garante apenas a comunicação entre os nós; a replicação e tolerância a falhas das filas é definida posteriormente, conforme exemplos acima.
